# ğŸ¤– ADK Multi-Agent Framework â€” Cursor Vibe Coding Prompt

> Copy this entire prompt into Cursor's AI chat (or any AI coding assistant).
> It will scaffold the full framework from scratch, ready to extend.

---

## PROMPT START â€” COPY EVERYTHING BELOW THIS LINE

---

You are an expert Python architect specializing in Google ADK (Agent Development Kit) multi-agent systems.

Build me a **production-grade agent management framework** on top of Google ADK that lets me manage a large number of nested agents (potentially 50â€“100+) without manual wiring. I want a clean, scalable codebase I can extend indefinitely.

---

## STACK & DEPENDENCIES

- **Python 3.11+**
- **Google ADK** (`pip install google-adk`) â€” use `LlmAgent`, `SequentialAgent`, `ParallelAgent`, `BaseAgent`
- **Pydantic v2** â€” for config/schema validation if needed
- **Standard library only** for the framework core (`importlib`, `pkgutil`, `contextvars`, `dataclasses`, `logging`, `asyncio`)
- Default LLM model: `gemini-2.0-flash` (configurable per agent)

---

## ARCHITECTURE OVERVIEW

Build this exact layered architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   main.py (entry point)              â”‚
â”‚   bootstrap â†’ middleware â†’ discover â†’ resolve â†’ run  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               framework/core.py                      â”‚
â”‚   ToolRegistry | AgentRegistry | @tool | @agent      â”‚
â”‚   Middleware pipeline | ContextVars | discover()     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               agents/ package                        â”‚
â”‚   tools.py          â† all tool functions             â”‚
â”‚   root.py           â† custom intent router           â”‚
â”‚   <domain>/         â† one sub-package per domain     â”‚
â”‚     __init__.py     â† domain-level agent             â”‚
â”‚     leaf_agents.py  â† leaf LLM agents                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## PROJECT STRUCTURE

Generate this exact file structure:

```
project/
â”œâ”€â”€ framework/
â”‚   â”œâ”€â”€ __init__.py         â† re-export public API
â”‚   â””â”€â”€ core.py             â† entire framework engine
â”œâ”€â”€ agents/
â”‚   â”œâ”€â”€ __init__.py         â† empty package marker
â”‚   â”œâ”€â”€ tools.py            â† all tool functions
â”‚   â”œâ”€â”€ root.py             â† RootAgent (custom BaseAgent router)
â”‚   â”œâ”€â”€ <domain_1>/
â”‚   â”‚   â”œâ”€â”€ __init__.py     â† domain agent (Sequential or Parallel)
â”‚   â”‚   â””â”€â”€ leaf_agents.py  â† leaf LLM agents
â”‚   â””â”€â”€ <domain_2>/         â† repeat for each domain
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ leaf_agents.py
â””â”€â”€ main.py                 â† bootstrap + ADK runner
```

Replace `<domain_1>`, `<domain_2>` with the actual business domains I describe below.

---

## FRAMEWORK ENGINE â€” `framework/core.py`

Implement **all of the following** in a single file:

### A. ContextVars (implicit per-request state)

```python
from contextvars import ContextVar
current_user: ContextVar[dict] = ContextVar("current_user", default={})
current_session: ContextVar[str] = ContextVar("current_session", default="unknown")
```

These must be readable from any tool or agent without passing them as parameters.

### B. Middleware Protocol + 3 built-in implementations

Define a `Protocol` class:
```python
class AgentMiddleware(Protocol):
    async def before_call(self, agent_name: str, inputs: dict) -> dict: ...
    async def after_call(self, agent_name: str, inputs: dict, output: Any) -> Any: ...
```

Implement:
1. **`LoggingMiddleware`** â€” logs `[â†’] CALL agent=... session=... user=...` and `[â†] RETURN agent=...` using the `logging` module
2. **`TracingMiddleware`** â€” measures wall-clock latency per agent using `time.perf_counter()`, logs `[TRACE] agent=... elapsed=Xms`
3. **`MetricsMiddleware`** â€” accumulates call count and total latency per agent; exposes a `.report() -> str` method that prints a formatted summary table

### C. ToolRegistry

```python
@dataclass
class ToolDefinition:
    name: str
    fn: Callable
    description: str
    tags: list[str]

class ToolRegistry:
    _tools: dict[str, ToolDefinition] = {}

    @classmethod
    def register(cls, name, description, tags=None): ...   # returns decorator
    @classmethod
    def get(cls, name) -> ToolDefinition | None: ...
    @classmethod
    def get_callables(cls, names: list[str]) -> list[Callable]: ...  # raises KeyError if missing
    @classmethod
    def all(cls) -> dict: ...
```

### D. AgentRegistry

```python
@dataclass
class AgentDefinition:
    name: str
    agent_type: str        # "llm" | "sequential" | "parallel" | "custom"
    factory: Callable      # factory(tools, sub_agents) â†’ ADK agent instance
    tools: list[str]
    sub_agents: list[str]
    parent: str | None
    description: str
    _instance: Any = None  # cached after first resolve

class AgentRegistry:
    _agents: dict[str, AgentDefinition] = {}
    _middleware: list[AgentMiddleware] = []

    @classmethod
    def register(cls, definition: AgentDefinition): ...

    @classmethod
    def add_middleware(cls, *middleware): ...

    @classmethod
    def resolve(cls, name: str) -> Any:
        # MUST be recursive: resolve sub_agents first, then call factory
        # MUST cache result in _instance so it's a singleton
        ...

    @classmethod
    def get_tree(cls, root="root_agent", indent=0) -> str:
        # Returns indented tree like:
        # root_agent [custom]
        #   â””â”€ sales_agent [sequential]
        #        â””â”€ product_catalog_agent [llm]  tools=[search_products]
        ...

    @classmethod
    def all(cls) -> dict: ...

    @classmethod
    def reset(cls): ...   # clears all _instance caches (for testing)
```

### E. `@tool` decorator

```python
def tool(name: str, description: str, tags: list[str] | None = None):
    """Registers a plain function into ToolRegistry at import time."""
    return ToolRegistry.register(name, description, tags)
```

### F. `@agent` class decorator

```python
def agent(
    name: str,
    agent_type: str = "llm",
    tools: list[str] | None = None,
    sub_agents: list[str] | None = None,
    parent: str | None = None,
    description: str = "",
):
    """
    Registers a class into AgentRegistry at import time.
    The decorated class MUST implement:
        @staticmethod
        def build(tools: list[Callable], sub_agents: list) -> <ADK agent>
    """
```

### G. `discover(package_name: str)` function

```python
def discover(package_name: str) -> None:
    """
    Walks every module in the given package using pkgutil.walk_packages
    and imports each one. Because decorators fire at import time,
    this single call populates both registries automatically.
    """
```

---

## AGENT PATTERNS â€” HOW TO IMPLEMENT EACH TYPE

### LLM Agent (leaf node)
```python
@agent(name="my_agent", agent_type="llm", tools=["tool_a", "tool_b"], parent="parent_agent")
class MyAgent:
    @staticmethod
    def build(tools: list, sub_agents: list) -> LlmAgent:
        return LlmAgent(
            name="my_agent",
            model="gemini-2.0-flash",
            instruction="You are a specialist that...",
            tools=tools,
        )
```

### Sequential Agent (ordered pipeline)
```python
@agent(name="pipeline_agent", agent_type="sequential", sub_agents=["step1", "step2"], parent="root_agent")
class PipelineAgent:
    @staticmethod
    def build(tools: list, sub_agents: list) -> SequentialAgent:
        return SequentialAgent(name="pipeline_agent", sub_agents=sub_agents)
```

### Parallel Agent (concurrent execution)
```python
@agent(name="parallel_agent", agent_type="parallel", sub_agents=["worker_a", "worker_b"], parent="root_agent")
class MyParallelAgent:
    @staticmethod
    def build(tools: list, sub_agents: list) -> ParallelAgent:
        return ParallelAgent(name="parallel_agent", sub_agents=sub_agents)
```

### Custom Agent (full control, routing logic)
```python
class _RouterImpl(BaseAgent):
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        # classify intent from ctx.session.events[-1]
        # delegate to correct sub_agent
        target = next(a for a in self.sub_agents if a.name == chosen_name)
        async for event in target.run_async(ctx):
            yield event

@agent(name="root_agent", agent_type="custom", sub_agents=[...])
class RootAgent:
    @staticmethod
    def build(tools, sub_agents) -> _RouterImpl:
        return _RouterImpl(name="root_agent", sub_agents=sub_agents)
```

---

## BUSINESS DOMAIN â€” WHAT TO BUILD

> **[REPLACE THIS SECTION with your actual domain when using the prompt]**

Build an **e-commerce customer platform** with the following agent hierarchy:

```
root_agent [custom â€” intent router]
  â”œâ”€â”€ sales_agent [sequential]
  â”‚     â”œâ”€â”€ product_catalog_agent [llm]   tools: search_products, get_product_details
  â”‚     â””â”€â”€ order_agent [llm]             tools: check_inventory, create_order
  â”œâ”€â”€ support_agent [parallel]
  â”‚     â”œâ”€â”€ ticket_agent [llm]            tools: create_ticket, get_ticket_status, escalate_ticket
  â”‚     â””â”€â”€ knowledge_base_agent [llm]    tools: search_knowledge_base
  â””â”€â”€ finance_agent [sequential]
        â”œâ”€â”€ billing_agent [llm]           tools: get_invoice, process_payment
        â””â”€â”€ refund_agent [llm]            tools: check_refund_eligibility, process_refund
```

**Intent routing rules** (implement in `root.py` using regex on user message):
- keywords: `buy / order / purchase / product / price / stock` â†’ `sales_agent`
- keywords: `help / issue / problem / not working / ticket / bug / error` â†’ `support_agent`
- keywords: `invoice / payment / bill / charge / refund / receipt` â†’ `finance_agent`
- fallback â†’ `support_agent`

**Tools** (all in `agents/tools.py`, use simulated/mock return data):

| Tool name | Parameters | Returns |
|---|---|---|
| `search_products` | query, category, limit | list of matching products |
| `get_product_details` | product_id | specs, price, stock, rating |
| `check_inventory` | product_id, quantity | available count, in_stock bool |
| `create_order` | product_id, quantity, shipping_address | order_id, status, eta_days |
| `create_ticket` | subject, description, priority | ticket_id, sla_hours |
| `get_ticket_status` | ticket_id | status, last_note, updated |
| `search_knowledge_base` | query, limit | list of matching articles |
| `escalate_ticket` | ticket_id, reason, tier | new status, new sla |
| `get_invoice` | invoice_id | amount, status, due_date, items |
| `process_payment` | invoice_id, amount, payment_method | success, transaction_id |
| `check_refund_eligibility` | order_id | eligible bool, days_since_purchase, reason |
| `process_refund` | order_id, amount, reason | refund_id, eta_days |

All tools should:
- Read `current_user.get()` to include customer ID in responses
- Return realistic-looking mock data (use `random` for IDs and variability)
- Be decorated with `@tool(name=..., description=..., tags=[...])`

---

## `main.py` â€” BOOTSTRAP SEQUENCE

Implement in this exact order:

```python
async def main():
    # 1. Configure logging (DEBUG level, human-readable format)
    # 2. Instantiate metrics = MetricsMiddleware()
    # 3. AgentRegistry.add_middleware(LoggingMiddleware(), TracingMiddleware(), metrics)
    # 4. discover("agents")            â† auto-imports everything
    # 5. Print AgentRegistry.get_tree(root="root_agent")
    # 6. root = AgentRegistry.resolve("root_agent")   â† lazy build
    # 7. runner = Runner(agent=root, app_name=..., session_service=InMemorySessionService())
    # 8. Run 3 demo messages â€” one per intent â€” using runner.run_async(...)
    # 9. Print metrics.report()
```

For demo messages, set `current_user` and `current_session` ContextVars before each call.

---

## SYSTEM PROMPT QUALITY GUIDELINES

For every `LlmAgent`, write a **detailed, role-specific system prompt** that:
1. Declares a clear persona ("You are a billing specialist")
2. Lists numbered steps for the happy path
3. Handles the unhappy path explicitly (missing data, failures, edge cases)
4. Specifies which tool to call in which order
5. States any hard constraints ("Never approve a refund without calling check_refund_eligibility first")

---

## CODING STANDARDS â€” FOLLOW STRICTLY

1. **One class per agent** with a static `build()` method â€” no standalone functions as factories
2. **All registrations happen at decorator time** (import time) â€” `main.py` must not manually call any `register()` method
3. **Lazy instantiation** â€” `resolve()` builds agents on first call only; cached forever after
4. **Explicit sub-agent imports** â€” inside `agents/sales/__init__.py`, import leaf agents BEFORE the `@agent` decorator fires, so children are registered first:
   ```python
   from agents.sales.leaf_agents import ProductCatalogAgent, OrderAgent  # noqa: F401
   ```
5. **Type hints everywhere** â€” use `list[str]`, `dict[str, Any]`, `Callable`, `AsyncGenerator`
6. **`from __future__ import annotations`** at the top of every file
7. **No circular imports** â€” framework/ must never import from agents/
8. **Docstrings on every class and public method**

---

## TESTING CHECKLIST (verify after generating)

After generating all files, mentally verify:

- [ ] `discover("agents")` imports `agents.tools` â†’ all `@tool` decorators fire
- [ ] `discover("agents")` imports `agents.sales` â†’ which imports `agents.sales.leaf_agents` â†’ all `@agent` decorators fire bottom-up
- [ ] `AgentRegistry.resolve("root_agent")` builds the full tree without errors
- [ ] `AgentRegistry.get_tree()` prints a correct indented hierarchy
- [ ] The 3 demo messages each route to the correct domain agent
- [ ] No agent or tool is wired manually in `main.py`

---

## EXTENSIBILITY CONTRACT

The framework must make the following operations require **zero changes to existing files**:

| Operation | What to do |
|---|---|
| Add a new tool | Add `@tool` decorated function to `agents/tools.py` |
| Add a new leaf agent | New file with `@agent(parent="existing_agent")` |
| Add new domain | New sub-package under `agents/` + add name to `root_agent`'s `sub_agents` |
| Add middleware | Implement `before_call` / `after_call`, call `AgentRegistry.add_middleware()` in `main.py` |
| Swap LLM model | Change `model=` in the agent's `build()` method |
| Add routing intent | Add pattern to `_INTENT_PATTERNS` dict in `root.py` |

---

## WHAT NOT TO DO

- âŒ Do NOT import specific agents in `main.py` (discovery handles it)
- âŒ Do NOT instantiate agents directly â€” always use `AgentRegistry.resolve()`
- âŒ Do NOT put tool logic inside agent files â€” all tools live in `agents/tools.py`
- âŒ Do NOT use `global` variables â€” use `ContextVar` for shared state
- âŒ Do NOT hardcode agent names as strings anywhere except the `@agent(name=...)` declaration and the parent's `sub_agents` list
- âŒ Do NOT catch all exceptions silently â€” let errors surface with context

---

## DELIVERABLES

Generate the following files in order:

1. `framework/__init__.py`
2. `framework/core.py`
3. `agents/__init__.py`
4. `agents/tools.py`
5. `agents/sales/leaf_agents.py`
6. `agents/sales/__init__.py`
7. `agents/support/leaf_agents.py`
8. `agents/support/__init__.py`
9. `agents/finance/leaf_agents.py`
10. `agents/finance/__init__.py`
11. `agents/root.py`
12. `main.py`

After generating all files, show the final directory tree and the expected console output when `python main.py` is run.

---

## PROMPT END

---

## HOW TO CUSTOMIZE FOR YOUR OWN PROJECT

Replace the **Business Domain** section with your own:

```
## MY AGENT HIERARCHY

root_agent [custom]
  â”œâ”€â”€ <your_domain_1>_agent [sequential | parallel | custom]
  â”‚     â”œâ”€â”€ <leaf_agent_a> [llm]   tools: [tool_1, tool_2]
  â”‚     â””â”€â”€ <leaf_agent_b> [llm]   tools: [tool_3]
  â””â”€â”€ <your_domain_2>_agent [sequential]
        â”œâ”€â”€ <leaf_agent_c> [llm]   tools: [tool_4, tool_5]
        â””â”€â”€ <leaf_agent_d> [llm]   tools: [tool_6]

## MY TOOLS

| Tool name  | Parameters       | Returns         | Purpose              |
|------------|------------------|-----------------|----------------------|
| tool_1     | param_a, param_b | {result: ...}   | Does X               |
| tool_2     | param_c          | {data: ...}     | Does Y               |
```

**Quick guide on which agent type to pick:**

| Situation | Use |
|---|---|
| Steps depend on previous output (A â†’ B â†’ C) | `SequentialAgent` |
| Steps are independent and can run together | `ParallelAgent` |
| Need custom routing / branching / loops | Custom `BaseAgent` |
| Single task with tools, no sub-agents | `LlmAgent` |
